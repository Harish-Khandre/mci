
- ARRAYS
Pros:
1. Fast lookups
2. Fast push and pop
3. Ordered

Cons:
1. Insert and Delete 
2. fixed size for static arrays


- Hash table {map or set}
Pros:
1. Fast lookups
2. Fast Inserts
3. Flexible keys

Cons:
1. Unordered 
2. Slow key iteration

- Linked List
Pros: 
1. Fast insertion and deletion
2. Ordered
3. Flexible size

Cons:
1. Slow lookups
2. More memory 

- Stack + Queue
Pros:
1. Fast operations
2. Fast peek
3. Ordered

Cons:
1. Slow lookups

Linked list:
Stack is LIFO (Last in first out) a --> b --> c --> d
Queue is FIFO (First in first out)  a <-- b <-- c <-- d

- Trees
- Binary tree 
Pros: 
1. Better than O(n)
    2. Ordered
    3. Flexible Size

    Cons:
    1. No O(1) operations

    Balanced Trees are best and gives O(log n) operations 
    Unbalanced trees are bad and gives O(n) operations

    If you find a lot and insert not often AVL tree and vice versa
    for red black tree

    //     9
    //  4     20
    //1  6  15  170

    In order => Left, Root, Right. [ 1, 4, 6, 9, 15, 20, 170 ]

    Pre-order => Root, Left, Right. [ 9 , 4, 1, 6, 20, 15, 170 ]

    Post order => Left, Right, Root. [ 1, 6, 4, 15, 170, 20, 9  ]

    - Binary Heap 
    Pros:
1. Better than O(n)
    2. Priority
    3. Flexible Size
    4. Fast Insert

    Cons:
    1. Slow Lookup

    - Graph
    Pros: 
    1. Relationships

    Cons:
    2. Scaling is hard

    Directed graphs shows direction of their relations

    Cyclic graphs are cyclic as they are continuous 

    Weighted graphs shows the weight of data for the actions like google map
    is weighted graph and calculates the direction based on the weight of
    the graph

    Connected graphs are connected to every other node

    Dag: directed acyclic graph => [[a, d], [b, a], [b, c], [d, c]]

    Vice versa for each graph

    Node is referred vertex in graph
    Edge is connection between two vertex

    The way they are represented is adjacent list and adjacent matrix
    adjacent list: [{ to: 1, w: 10}, { to: 2, w:20}] 
    (^this is index 0)
    and for matrix just google it or https://frontendmasters.com/courses/algorithms/searching-an-adjacency-matrix/

    - Recursion 
    Pros :
    1. DRY
    2. Readability

    Cons:
    1. Large Stack

    BASE CASEEEEE !!!!!!!!!!!!!!!!!! Is IMPORTANT!
    Use when there is branching and directional factors like graphs, trees and all as well as when you cant use
    loops obviously for ex. Like maze solver or tree searching etc.

    - Sort 

    1 - Sort 10 schools around your house by distance:
    insertion sort

    2 - eBay sorts listings by the current Bid amount:
    radix or counting sort

    3 - Sort scores on ESPN
    Quick sort

    4 - Massive database (can't fit all into memory) needs to sort through past year's user data
    Merge Sort

    5 - Almost sorted Udemy review data needs to update and add 2 new reviews
    Insertion Sort

    6 - Temperature Records for the past 50 years in Canada
    radix or counting Sort
    Quick sort if decimal places

    7 - Large user name database needs to be sorted. Data is very random.
    Quick sort
      
    If worst case performance matters more than avg case then dont use Quick Sort instead use Merge Sort as it is
    stable as well as it always give O(n log (n)) performance although it has space complexity higher than Quick Sort

    - Search

    - BFS:
    Pros: 
    1. Shortest path
    2. Closer Nodes

    Cons:
    1. More memory

    - DFS:
    Pros:
    1. Less memory
    2. Does path exist?

    Cons:
    1. Can get slow

    If you know a solution is not far from the root of the tree:
    BFS

    If the tree is very deep and solutions are rare: 
    BFS - DFS will be slower

    If the tree is very wide:
    DFS - BFS will need too much memory, in a queue

    If solutions are frequent but located deep in the tree:
    DFS

    Determining whether a path exists between two nodes:
    DFS

    Finding the shortest path:
    BFS
